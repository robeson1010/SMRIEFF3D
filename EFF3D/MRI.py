# AUTOGENERATED! DO NOT EDIT! File to edit: 01_MRI.ipynb (unless otherwise specified).

__all__ = ['open_npy', 'MriTensorImage']

# Cell
from fastai.vision.all import *
import nibabel as nib
import SimpleITK as sitk
import tqdm
# from volumentations import *

# Cell
def open_npy(fn,cls=torch.Tensor):
    im = nib.load(str(fn)).get_fdata()
    im=np.expand_dims(im,axis=0)
    im=im/1000.0
    im[im>1]=1
    im[np.nonzero(im)]=(im[np.nonzero(im)]-0.288)/0.1
#     I = sitk.ReadImage(str(fn))
#     im = np.array(sitk.GetArrayFromImage(I))
    return cls(im)

class MriTensorImage(TensorBase):

    @classmethod
    def create(cls, data:(Path,str,ndarray)):

        if isinstance(data, Path) or isinstance(data, str):
            if str(data).endswith('gz'):
                im = open_npy(fn=data,cls=torch.Tensor)
        elif isinstance(data, ndarray):
            im = torch.from_numpy(data)
        else:
            im = data

#         im=im[[0,3,1,4,2,5],0:3,...]

        return cls(im)


    def show(self,ctx=None):

        visu_img =self[0,:,:,64]

        plt.imshow(visu_img,cmap="gray") if ctx is None else ctx.imshow(visu_img,cmap="gray")

        return ctx

#     def __repr__(self):
# #         return self

#         return (f'MriTensorImage: {self.shape}')


# Cell
@typedispatch
def show_batch(x:MriTensorImage, y, samples, ctxs=None, max_n=10, nrows=None, ncols=None, figsize=None, **kwargs):
    if ctxs is None: ctxs = get_grid(min(len(samples), max_n), nrows=nrows, ncols=ncols, figsize=figsize)
    ctxs = show_batch[object](x, y, samples, ctxs=ctxs, max_n=max_n, **kwargs)
    return ctxs

# Cell
import skimage.transform as skt
# import tqdm